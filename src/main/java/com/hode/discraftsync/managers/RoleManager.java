package com.hode.discraftsync.managers;

import com.hode.discraftsync.DiscraftSync;
import net.luckperms.api.LuckPerms;
import net.luckperms.api.LuckPermsProvider;
import net.luckperms.api.model.group.Group;
import net.luckperms.api.model.user.User;
import net.luckperms.api.node.types.InheritanceNode;
import org.bukkit.Bukkit;
import org.bukkit.configuration.file.FileConfiguration;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.*;
import java.util.stream.Collectors;

public class RoleManager {
    
    private final DiscraftSync plugin;
    private final ConfigManager configManager;
    private LuckPerms luckPerms;
    
    // Role mapping cache (LuckPerms group -> Discord role ID)
    private final Map<String, String> roleMappings = new HashMap<>();
    
    public RoleManager(DiscraftSync plugin) {
        this.plugin = plugin;
        this.configManager = plugin.getConfigManager();
        
        // Get LuckPerms API
        try {
            this.luckPerms = LuckPermsProvider.get();
            plugin.getLogger().info("Successfully hooked into LuckPerms!");
        } catch (IllegalStateException e) {
            plugin.getLogger().severe("Failed to hook into LuckPerms: " + e.getMessage());
        }
        
        loadRoleMappings();
    }
    
    private void loadRoleMappings() {
        FileConfiguration config = configManager.getRolesConfig();
        roleMappings.clear();
        
        // Load role mappings from config
        for (String key : config.getKeys(false)) {
            if (!key.equals("settings") && !key.startsWith("#")) {
                String roleId = config.getString(key, "");
                if (!roleId.isEmpty()) {
                    roleMappings.put(key, roleId);
                }
            }
        }
        
        plugin.getLogger().info("Loaded " + roleMappings.size() + " role mappings");
    }
    
    public boolean generateRolesConfig() {
        if (luckPerms == null) {
            return false;
        }
        
        try {
            // Get all LuckPerms groups
            Set<Group> groups = luckPerms.getGroupManager().getLoadedGroups();
            
            // Create new roles.yml content
            List<String> lines = new ArrayList<>();
            lines.add("# DiscraftSync Role Mapping Configuration");
            lines.add("# This file is AUTO-GENERATED by running /discraftsync or /sync command");
            lines.add("# ");
            lines.add("# Format: luckperms-group-name: \"discord-role-id\"");
            lines.add("# ");
            lines.add("# To get Discord Role IDs:");
            lines.add("# 1. Enable Developer Mode in Discord (User Settings > Advanced > Developer Mode)");
            lines.add("# 2. Right-click on a role in your server and select \"Copy ID\"");
            lines.add("# 3. Paste the role ID next to the corresponding group name below");
            lines.add("# ");
            lines.add("# Leave the role ID empty (\"\") to disable syncing for that group");
            lines.add("# ");
            lines.add("# =====================================================");
            lines.add("# AUTO-GENERATED FROM LUCKPERMS - LAST UPDATE: " + new Date().toString());
            lines.add("# Run /discraftsync to regenerate this file");
            lines.add("# =====================================================");
            lines.add("");
            
            // Sort groups by weight (higher weight = higher priority)
            List<Group> sortedGroups = groups.stream()
                .sorted((g1, g2) -> Integer.compare(g2.getWeight().orElse(0), g1.getWeight().orElse(0)))
                .collect(Collectors.toList());
            
            // Add each group
            for (Group group : sortedGroups) {
                String groupName = group.getName();
                String currentRoleId = roleMappings.getOrDefault(groupName, "");
                
                lines.add("# Group: " + groupName + " (Weight: " + group.getWeight().orElse(0) + ")");
                lines.add(groupName + ": \"" + currentRoleId + "\"");
                lines.add("");
            }
            
            // Write to file
            Files.write(
                new File(plugin.getDataFolder(), "roles.yml").toPath(),
                lines,
                StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING
            );
            
            // Reload config
            configManager.reloadConfigurations();
            loadRoleMappings();
            
            return true;
            
        } catch (Exception e) {
            plugin.getLogger().severe("Failed to generate roles.yml: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    public void syncUserRoles(String ign, List<String> discordRoleIds) {
        if (luckPerms == null) {
            return;
        }

        // Since we're using IGN-based system, we need to create a UUID from the IGN
        UUID uuid = UUID.nameUUIDFromBytes(("OfflinePlayer:" + ign).getBytes());
        
        // Get user from LuckPerms
        User user = luckPerms.getUserManager().getUser(uuid);
        if (user == null) {
            // Try loading user if not cached
            luckPerms.getUserManager().loadUser(uuid)
                .thenAccept(loadedUser -> {
                    if (loadedUser != null) {
                        performRoleSync(loadedUser, discordRoleIds, ign);
                    }
                });
            return;
        }
        
        performRoleSync(user, discordRoleIds, ign);
    }
    
    private void performRoleSync(User user, List<String> discordRoleIds, String ign) {
        // Find highest priority group user should have
        String targetGroup = findHighestPriorityGroup(discordRoleIds);
        
        if (targetGroup == null) {
            targetGroup = configManager.getDefaultLuckPermsGroup();
        }
        
        // Get current primary group
        String currentGroup = user.getPrimaryGroup();
        
        if (!currentGroup.equals(targetGroup)) {
            // Remove current group and add new one
            user.data().remove(InheritanceNode.builder(currentGroup).build());
            user.data().add(InheritanceNode.builder(targetGroup).build());
            
            // Set as primary group
            user.getPrimaryGroup();
            
            // Save changes
            luckPerms.getUserManager().saveUser(user);
            
            plugin.getLogger().info("Updated " + ign + " from group " + currentGroup + " to " + targetGroup);
            
            // Update last sync time
            plugin.getLinkManager().updateLastSync(
                plugin.getLinkManager().getLinkedDiscordId(user.getUsername())
            );
        }
    }
    
    private String findHighestPriorityGroup(List<String> discordRoleIds) {
        // Check role mappings in order of LuckPerms group weight
        for (Map.Entry<String, String> mapping : roleMappings.entrySet()) {
            String groupName = mapping.getKey();
            String roleId = mapping.getValue();
            
            if (discordRoleIds.contains(roleId)) {
                return groupName;
            }
        }
        
        return null;
    }
    
    public String getDiscordRoleForGroup(String groupName) {
        return roleMappings.get(groupName);
    }
    
    public String getGroupForDiscordRole(String roleId) {
        return roleMappings.entrySet().stream()
            .filter(entry -> entry.getValue().equals(roleId))
            .map(Map.Entry::getKey)
            .findFirst()
            .orElse(null);
    }
    
    public Map<String, String> getRoleMappings() {
        return new HashMap<>(roleMappings);
    }
    
    public int getTotalMappings() {
        return roleMappings.size();
    }
    
    public void reloadRoleMappings() {
        loadRoleMappings();
    }
}